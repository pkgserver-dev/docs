{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to <code>pkgserver</code>, your solution for streamlined KRM package management in conjunction with GitOps systems. <code>Pkgserver</code> is designed to empower operators, developers and/or platform engineers to deploy applications and configurations seamlessly in various environments.</p> <p>With <code>pkgserver</code>, you can embrace continuous delivery practices, ensuring swift and reliable rollouts of changes to your systems. Whether you're managing infrastructure, deploying application in development or production settings, <code>pkgserver</code> provides the tools you need to streamline and automate the deployment process.</p> <p>The <code>pkgserver</code> is tailored to meet the needs of modern infrastructure/application management, offering robust features for managing fleet systems at scale. From orchestrating deployments to tracking changes across your environment, <code>pkgserver</code> aims to simplify the complexities of <code>package</code> management, allowing you to focus on delivering value to your users.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>As the name suggests, the <code>pkgserver</code> manages <code>packages</code>. Fundamentally, a <code>package</code> is a set of Kubernetes Resource Model (KRM) resources in YAML format. These resources may include artifacts of software components, configuration artifacts, or a combination thereof. By leveraging KRM, <code>pkgserver</code> provides a flexible and extensible framework for defining and managing complex software systems, through a well defined API framework.</p> <p>To facilitate the organization of <code>packages</code>, the <code>pkgserver</code> leverages <code>repositories</code> to manage <code>packages</code>. Within this framework, <code>pkgserver</code> distinguishes between two primary types of <code>repositories</code>: deployment/catalog <code>repositories</code>.</p> <p>Catalog <code>repositories</code>, also known as blueprint <code>repositories</code>, serve as templates for software components and configurations.<code>Packages</code> in these <code>repositories</code> define the structure and composition of the desired KRM resources, providing a standardized framework for deployment.</p> <p>On the other hand, deployment <code>repositories</code> holds <code>packages</code> with actual artifacts necessary for deployment, including software components and configuration artifacts. These <code>packages</code> contain the tangible elements required to instantiate the deployment artifacts.</p> <pre><code>graph TD;\n    subgraph \"Package Organization\"\n        RepositoryC[Repository Catalog];\n        RepositoryD[Repository Deployment];\n        PackageC[Package Catalog];\n        PackageD[Package Deployment];\n        RepositoryC --&gt; |1:N| PackageC;\n        RepositoryD --&gt; |1:N| PackageD;\n    end</code></pre> <p>Central to the functionality of <code>pkgserver</code> is its robust lifecycle management system for packages. This system encompasses essential operations such as discovery, creation, reading, updating, and deletion of <code>packages</code>, commonly referred to as CRUD operations.</p> <p>Additionally, <code>pkgserver</code> offers comprehensive versioning capabilities, allowing users to track and manage changes to packages over time. This ensures traceability and facilitates the implementation of controlled release processes.</p> <p><code>Pkgserver</code> extends the Kubernetes API with dedicated resources (<code>PackageRevision</code>/<code>PackageRevisonResources</code>), ensuring a tailored approach to managing <code>packages</code> within Kubernetes environments. Through these API extension the, <code>Pkgserver</code> architecture allows for seamless integration with different applications leveraging the event-driven API framework of Kubernetes. This capability empowers users to customize specific scenarios and workflows tailored to their unique requirements. Examples include <code>Package Specialization</code>, <code>Package Approval</code>, <code>Package Validation</code>, <code>Package Dependencies</code>, etc.</p> <pre><code>graph TD;\n    subgraph \"PkgServer Architecture\"\n        PkgServerAPI[API Server];\n        PkgRevisionController;\n        PkgServerApp1[Custom Application 1];\n        PkgServerApp2[Custom Application 2];\n        PkgServerDB[Version Controlled Backend];\n        PkgServerAPI --&gt; PkgServerDB;\n        PkgRevisionController --&gt; PkgServerAPI;\n        PkgServerApp1 --&gt; PkgServerAPI;\n        PkgServerApp2 --&gt; PkgServerAPI;\n    end</code></pre>"},{"location":"#join-us","title":"Join us","text":"<p>Join us on this journey as we redefine package management and deployment for the next generation of software development and infrastructure/application engineering.</p> <p>Have questions, ideas, bug reports or just want to chat? Come join our discord server.</p>"},{"location":"01-getting-started/01_install/","title":"Getting Started","text":"<p>First check the prerequisites</p> <p>create a k8s cluster</p> <p>install pkgserver</p> <pre><code>kubectl apply -f https://github.com/pkgserver-dev/pkgserver/blob/main/artifacts/out/artifact.yaml\n</code></pre> <p>verify if pkgserver is running</p> <pre><code>kubectl get pods -n pkg-system \n</code></pre> <pre><code>NAME                          READY   STATUS    RESTARTS   AGE\npkg-server-85fc8896f9-xmrmt   1/1     Running   0          3h\n</code></pre> <pre><code>kubectl api-resources| grep package\npackagevariants                                config.pkg.pkgserver.dev/v1alpha1      true         PackageVariant\npackagerevisionresourceses                     pkg.pkgserver.dev/v1alpha1             true         PackageRevisionResources\npackagerevisions                               pkg.pkgserver.dev/v1alpha1             true         PackageRevision\n</code></pre> <p>register a catalog repository</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: config.pkg.pkgserver.dev/v1alpha1\nkind: Repository\nmetadata:\nname: repo-catalog\nspec:\ntype: git\ndeployment: false\ngit:\nurl: https://github.com/pkgserver-dev/pkgserver-demo-catalog.git\nEOF\n</code></pre> <pre><code>kubectl get repositories.config.pkg.pkgserver.dev repo-catalog \n</code></pre> <p>the following output is expected</p> <pre><code>NAME           READY   DEPLOYMENT   TYPE   ADDRESS\nrepo-catalog   True                 git    https://github.com/pkgserver-dev/pkgserver-demo-catalog.git\n</code></pre> <p>you should see the following packages appear since the pkgserver discover packages automatically for catalog repositories</p> <pre><code>kubectl get packagerevisions.pkg.pkgserver.dev --field-selector=spec.packageID.repository=repo-catalog\n</code></pre> <p>Expected output</p> <pre><code>NAME                                 REPOSITORY     PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ncatalog.repo-catalog.nf.example.v1   repo-catalog   example   v1         v1          published\ncatalog.repo-catalog.nf.example.v2   repo-catalog   example   v2         v2          published\ncatalog.repo-catalog.nf.example.v3   repo-catalog   example   v3         v3          published\n</code></pre>"},{"location":"01-getting-started/02_prereq/","title":"Prerequisites","text":""},{"location":"01-getting-started/02_prereq/#kubectl","title":"kubectl","text":"<p>Install kubectl</p>"},{"location":"01-getting-started/02_prereq/#auto-completions-for-kubectl-optional","title":"Auto completions for kubectl (optional)","text":"bashzsh <pre><code>source &lt;(kubectl completion bash)\nalias k=kubectl\ncomplete -o default -F __start_kubectl k\n</code></pre> <pre><code>source &lt;(kubectl completion zsh)\nalias k=kubectl\ncomplete -F _start_kubectl k\n</code></pre>"},{"location":"01-getting-started/02_prereq/#pkgctl-optional","title":"pkgctl (optional)","text":"<p>pkgctl is a single binary built for linux and Mac OS, distributed via ghreleases specialized to interface with the pkgserver.</p> linux/Mac OSPackages <p>To download &amp; install the latest release the following automated installation script can be used.</p> <pre><code>bash -c \"$(curl -sL https://github.com/pkgserver-dev/pkgctl/raw/main/install.sh)\"\n</code></pre> <p>As a result, the latest <code>pkgctl</code> version will be installed in the /usr/local/bin directory and the version information will be printed out.</p> <p>To install a specific version of <code>pkgctl</code>, provide the version with -v flag to the installation script:</p> <pre><code>bash -c \"$(curl -sL https://github.com/pkgserver-dev/pkgctl/raw/main/install.sh)\" -- -v 0.2.0\n</code></pre> <p>Linux users running distributions with support for deb/rpm packages can install gnmic using pre-built packages:</p> <pre><code>bash -c \"$(curl -sL https://github.com/pkgserver-dev/pkgctl/raw/main/install.sh)\" -- --use-pkg\n</code></pre>"},{"location":"01-getting-started/02_prereq/#install-kubernetes-optional","title":"Install Kubernetes (optional)","text":"<p>pkgserver does not have dependencies on a particular k8s distribution. You can install any of the distributions you like. Below we listed some options. </p> kindother <p>First install kind using kind</p> <p>In this example we install a <code>kind</code> cluster with name <code>sdc</code>. </p> <pre><code>kind create cluster --name sdc\n</code></pre>"},{"location":"02-concepts/01_about/","title":"Concepts","text":"<p>As the name suggests, the <code>pkgserver</code> manages <code>packages</code>. Fundamentally, a <code>package</code> is a set of Kubernetes Resource Model (KRM) resources in YAML format. These resources may include artifacts of software components, configuration, or a combination thereof. By leveraging KRM, <code>pkgserver</code> provides a flexible and extensible framework for defining and managing complex systems, through a well defined API framework.</p> <p>To facilitate the organization of <code>packages</code>, the <code>pkgserver</code> leverages <code>repositories</code> to manage <code>packages</code>. Within this framework, <code>pkgserver</code> distinguishes between two primary types of <code>repositories</code>: deployment/catalog <code>repositories</code>.</p> <p>Catalog <code>repositories</code>, also known as blueprint <code>repositories</code>, serve as templates for software components and configurations.<code>Packages</code> in these <code>repositories</code> define the structure and composition of the desired KRM resources, providing a standardized framework for deployment.</p> <p>On the other hand, deployment <code>repositories</code> holds <code>packages</code> with actual artifacts necessary for deployment, including software components and configuration artifacts. These <code>packages</code> contain the tangible elements required to instantiate the deployment artifacts.</p> <pre><code>graph TD;\n    subgraph \"Package Organization\"\n        RepositoryC[Repository Catalog];\n        RepositoryD[Repository Deployment];\n        PackageC[Package as Catalog];\n        PackageD[Package for Deployment];\n        RepositoryC --&gt; |1:N| PackageC;\n        RepositoryD --&gt; |1:N| PackageD;\n    end</code></pre> <p>Central to the functionality of <code>pkgserver</code> is its robust lifecycle management system for packages. This system encompasses essential operations such as discovery, creation, reading, updating, and deletion of <code>packages</code>, commonly referred to as CRUD operations.</p> <p>Additionally, <code>pkgserver</code> offers comprehensive versioning capabilities, allowing users to track and manage changes to packages over time. This ensures traceability and facilitates the implementation of controlled release processes.</p>"},{"location":"02-concepts/01_about/#pkgserver-resources","title":"PkgServer Resources","text":"<p>PkgServer manages the following resources:</p> <ul> <li> <p>Repositories: A <code>repository</code> is a way to organize and manage <code>packages</code>. The <code>pkgserver</code> distinguishes between two primary types of <code>repositories</code>: deployment repositories and catalog/blueprint repositories.</p> </li> <li> <p>PackageRevisions: A specific revision of a <code>package</code> managed by the <code>pkgserver</code> in one of the registered <code>repositories</code>. This resource represents a metadata view of a specific <code>package</code> revision.</p> </li> <li> <p>PackageRevisionResources: this resource represents the contents of a package revision (KRM resources contained in the package).</p> </li> </ul> <p><code>PackageRevisions</code> and <code>PackageRevisionResources</code> represent different views of the same underlying <code>package</code>. <code>PackageRevisions</code> represents the <code>package</code> metadata, and <code>PackageRevisionResources</code> represents the <code>package</code> content.</p>"},{"location":"02-concepts/02_repository/","title":"Repository","text":"<p>A <code>repository</code> serves as the resource for organizing and managing <code>package</code>s within the <code>pkgserver</code>. The primary objective of the <code>pkgserver</code> project is to maintain versatility, ensuring compatibility with various version control backends. While initial emphasis is placed on GIT and OCI repositories, the architecture remains flexible to accommodate other options as needed.</p> <p>Marking a repository for deployment signifies its readiness to orchestrate the deployment of packages to target systems. This distinction underscores the pivotal role repositories play in facilitating the seamless transition of packages from development to production environments. Typically blueprint/catalog <code>packages</code> are placed in <code>repositories</code> where the deployment flag is not set, while deployment packages are placed in repositories with the deployment flag set.</p> <p>Furthermore, a critical consideration in defining a <code>repository</code> lies in configuring the permissions required for lifecycle activities that can be performed by the <code>pkgserver</code>. While public git repositories may grant read access to all, certain actions such as creating branches or committing changes necessitate specific access rights through tokens. Therefore, when configuring a repository, it becomes imperative to delineate the tasks pkgserver is authorized to perform. For instance, blueprint packages may not inherently require full CRUD permissions, necessitating a tailored approach to permissions management and as such tokens could be omitted from the configuration</p> <p>In essence, deploying a repository entails a dual consideration: ensuring its readiness for package deployment and delineating the requisite permissions to facilitate lifecycle activities within the pkgserver environment.</p>"},{"location":"02-concepts/03_package/","title":"Package","text":"<p>A <code>package</code> represents a collection of KRM resources, organized within a repository and utilizing <code>YAML</code> as the file format. These resources, defined in the Kubernetes Resource Model, encapsulate configurations, definitions, and metadata necessary to deploy and manage specific functionalities or components within a system. Each <code>package</code> is structured to encapsulate related resources, ensuring modularity, portability, and ease of management in various environments. A <code>package</code> is contained within a directory of a repsoitory.</p> <p>Practically a package can be used in various ways (e.g. a certManager package would be a package to ), Configuration artifacts</p>"},{"location":"02-concepts/03_package/#packagerevision","title":"PackageRevision","text":"<p>A <code>package</code> in the <code>pkgserver</code> is represented through a <code>PackageRevision</code> resource in the Kubernetes API server. </p>"},{"location":"02-concepts/03_package/#identification","title":"Identification","text":"<p>A <code>PackageRevision</code> is uniquely identified by the following parameters:</p> <p>Target: Specifies the deployment target where the package will be deployed.</p> <p>Repository: Indicates the repository hosting the package.</p> <p>Realm: Represents a logical grouping or domain name that associates related packages together.</p> <p>Package: Denotes the name of the package.</p> <p>Workspace: Specifies the working environment or branch where the package is being edited.</p> <p>Revision: Signifies a unique identifier for a specific revision of the package. This parameter becomes relevant once the package is published.</p>"},{"location":"02-concepts/03_package/#lifecycle","title":"Lifecycle","text":"<p>A <code>PackageRevision</code> defines the revision of a package and is managed through a state machine. A <code>PackageRevision</code> can exist in the following states within the state machine:</p> <p>Draft: The initial state of a package revision. In this state, the <code>package revision</code> is actively being developed and is not yet ready for publication.     When using a Git Repository, the <code>package</code> is contained within a specific workspace branch representing the package revision.</p> <p>Proposed: Transitioning from the Draft state, a <code>package revision</code> enters the Proposed state when it is submitted for review and consideration for publication. This is an administrative action without influence on the revision backend.</p> <p>Published: Once approved, a <code>package revision</code> moves into the Published state, indicating that it is publicly available for consumption. At this stage, the <code>package</code> receives a specific <code>package revision</code> identifier that uniquely identifies the package.     When using a Git Repository, the package is merged into the main branch and tagged with a specific <code>package revision</code> tag that uniquely identifies the package.</p> <p>Deletion Proposed: In certain circumstances, a <code>package revision</code> may be marked for deletion. It enters the Deletion Proposed state pending approval for removal. This is an administrative action without influence on the revision backend.</p> <p>Deleted: The final state of a <code>package revision</code>, indicating that it has been removed from the system and is no longer accessible. If a <code>package revisio</code>n ever had a <code>package revision</code> identifier, the tag will be deleted when it transitions to the Deleted state.</p> <pre><code>graph TD;\n    subgraph \"Package Lifecycle\"\n        Deleted;\n        DeletionProposed;\n        Published;\n        Draft;\n        Proposed;\n        Deleted -- \"Create (Create Branch)\" --&gt; Draft;\n        DeletionProposed -- \"Delete (Delete Tag)\" --&gt; Deleted;\n        DeletionProposed -- \"Update (Lifecycle: Publish)\" --&gt; Published;\n        Draft -- \"Delete\" --&gt; Deleted;\n        Draft -- \"Update (Lifecycle: Draft)\" --&gt; DeletionProposed;\n        Draft -- \"Update (Lifecycle: Proposed)\" --&gt; Proposed;\n        Proposed -- \"Delete\" --&gt; Deleted;\n        Proposed -- \"Update (Lifecycle: Draft)\" --&gt; Draft;\n        Proposed -- \"Update (Lifecycle: Publish) (Create TAG, merge WS branch to main)\"--&gt; Published;\n        Proposed -- \"Update (Lifecycle: Deletion proposed)\" --&gt; DeletionProposed;\n        Published -- \"Update (Lifecycle: Deletion proposed)\" --&gt; DeletionProposed;\n\n    end</code></pre> <p>When a PackageRevision transitions to the Published state, two critical points should be noted: A unique revision is allocated for the PackageRevision and no further changes to the content are permitted. Any necessary modifications require the creation of a new packagerevision</p>"},{"location":"02-concepts/03_package/#packagerevisionresources","title":"PackagerevisionResources","text":"<p>A <code>PackageRevisionResource</code> serves as the api for accessing and updating the contents of a package revision, which comprises KRM resources contained within the package. When an application needs to retrieve specific content from a package revision, it utilizes the <code>PackageRevisionResource</code> api. Similarly, updating the content of a package revision is facilitated through interactions with the PackageRevisionResource resource. For example, a developer may use the <code>PackageRevisionResource</code> to fetch configuration files or software components stored within a package revision, or to update these resources with new versions or configurations.</p>"},{"location":"03-userguide/01_about/","title":"UserGuide","text":"<p>In the userguide we show a number of scenario how the <code>packageserver</code> would be used to manage packages.</p> <p>The pkgserver project offers two primary methods for interacting with the <code>pkgserver</code>:</p> <ul> <li> <p>Using <code>kubectl</code>, the main Kubernetes CLI tool, allows users to explore the packageserver API in a generic manner.</p> </li> <li> <p>Alternatively, users can utilize the <code>pkgctl</code> CLI, a dedicated tool specifically designed as a wrapper around the <code>pkgserver</code> API. pkgctl provides additional capabilities, such as presenting content in a more user-friendly format and enabling local editing and exploration of package content.</p> </li> </ul> <p>In the various sections of the user guide we will explain both options with its capabilities.</p>"},{"location":"03-userguide/02_register_catalog_repo/","title":"Registering a catalog/blueprint repository","text":"<p>First a git repository must be created. We use the pkgserver on github repo one in this tutorial. Given this will be used as a catalog repo we set the deployment attribute to false. Also note that we do not provide any secret, which means that this repository can not be edited by the pkgserver. Basically given this is a public github repository the pkgserver can only read the resources and its content of the packages.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: config.pkg.pkgserver.dev/v1alpha1\nkind: Repository\nmetadata:\nname: repo-catalog\nspec:\ntype: git\ndeployment: false\ngit:\nurl: https://github.com/pkgserver-dev/pkgserver-demo-catalog.git\nEOF\n</code></pre> <p>By executing the following command you should see the status of the repository. The repository has a READY condition indicating the success or failure of the reconcilation status of the repository resource. E.g if the repository is not accessible a false READY state will be indicated</p> <p>when executing the following command</p> <pre><code>kubectl get repositories.config.pkg.pkgserver.dev repo-catalog \n</code></pre> <p>the following output is expected</p> <pre><code>NAME           READY   DEPLOYMENT   TYPE   ADDRESS\nrepo-catalog   True                 git    https://github.com/pkgserver-dev/pkgserver-demo-catalog.git\n</code></pre> <p>For non deployment repositories the packageserver tries to discover existing packages in the repository and they will appear as packagerevisions through the following command.</p> <p>e.g when executing the following command we should see various packages.</p> <pre><code>kubectl get packagerevisions.pkg.pkgserver.dev --field-selector=spec.packageID.repository=repo-catalog\n</code></pre> <p>Expected output</p> <pre><code>NAME                                 REPOSITORY     PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ncatalog.repo-catalog.nf.example.v1   repo-catalog   example   v1         v1          published\ncatalog.repo-catalog.nf.example.v2   repo-catalog   example   v2         v2          published\ncatalog.repo-catalog.nf.example.v3   repo-catalog   example   v3         v3          published\n</code></pre> <p>The content of a specific package revision can be viewed using the following command.</p> <pre><code>kubectl describe packagerevisionresourceses.pkg.pkgserver.dev catalog.repo-catalog.nf.example.v3 \n</code></pre> <pre><code>Name:         catalog.repo-catalog.nf.example.v3\nNamespace:    default\nLabels:       &lt;none&gt;\nAnnotations:  pkg.pkgserver.dev/DiscoveredPkgRev: true\nAPI Version:  pkg.pkgserver.dev/v1alpha1\nKind:         PackageRevisionResources\nMetadata:\nCreation Timestamp:  2024-05-14T18:39:43Z\nFinalizers:\npackagediscovery.pkg.pkgserver.dev/finalizer\npackagerevision.pkg.pkgserver.dev/finalizer\nResource Version:  223532\nUID:               5abb5230-172d-4d00-b4e0-ebff6c7f85cd\nSpec:\nPackage ID:\nPackage:     example\nRealm:       nf\nRepository:  repo-catalog\nRevision:    v3\nTarget:      catalog\nWorkspace:   v3\nResources:\nartifacts.yaml:  ---\n# blockType: input, resourceID: context\n# defines the input of the Kform package as a configmap KRM resource\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: example\nnamespace: default\nannotations:\nkform.dev/block-type: input\nkform.dev/resource-id: context kform.dev/default: \"true\"\ndata:\nnetworkInstance: vpc-kform\nnetwork: knet1\nnode: a\nep: kep1\n---\n# blockType: provider, resourceID/name: kubernetes\n# defines the kubernetes provider configuration\napiVersion: kubernetes.provider.kform.dev/v1alpha1\nkind: ProviderConfig\nmetadata:\nname: kubernetes\nnamespace: default\nannotations:\nkform.dev/block-type: provider\n#spec: \n#  configPath: \"/Users/henderiw/.kube/config\"\n---\n# blockType: resource, resourceID: deployment, resourceType: kubernetes_manifest\n# deployment KRM resource that will be applied in the system\n# expressions are used to transform the KRM manifest before applying to the system\napiVersion: ipam.be.kuid.dev/v1alpha1\nkind: IPClaim\nmetadata:\nname: vpc-kform.claim1\nnamespace: default\nannotations:\nkform.dev/block-type: resource\nkform.dev/resource-type: kubernetes_manifest kform.dev/resource-id: ipclaim\nspec:\nindex: input.context[0].data.networkInstance\nselector:\nmatchLabels:\ninv.kuid.dev/network: input.context[0].data.network\nlabels:\ninv.kuid.dev/endpoint-name: input.context[0].data.ep\n---\n# blockType: output\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: output\nnamespace: default\ndata:\nprefix: kubernetes_manifest.ipclaim[0].status.address\ndefaultGateway: kubernetes_manifest.ipclaim[0].status.defaultGateway\nStatus:\n</code></pre>"},{"location":"03-userguide/03_register_deployment_repo/","title":"Registering a deployment repository","text":"<p>In addition to setting up a git repository, it is essential to generate an access token. This token authorizes the pkgserver to perform the necessary CRUD operations with the required permissions.</p> <p>Here is an example how this can be performed. Set the following environment variable</p> <pre><code>GITHUB_USERNAME=&lt;username&gt;\nGITHUB_TOKEN=&lt;token&gt;\n</code></pre> <p>using this command a git-pat secret is created</p> <pre><code>kubectl create secret generic git-pat \\\n  --from-literal=username=${GITHUB_USERNAME} \\\n  --from-literal=password=${GITHUB_TOKEN} \\\n  --type=kubernetes.io/basic-auth\n</code></pre> <p>With the following command a deployment repository is created that can be used for deployment and has the proper access right to perform the full lifecycle management of packages within this repository</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: config.pkg.pkgserver.dev/v1alpha1\nkind: Repository\nmetadata:\nname: repo-target\nspec:\ntype: git\ndeployment: true\ngit:\nurl: https://github.com/pkgserver-dev/pkgserver-demo-target.git\ncredentials: git-pat\nEOF\n</code></pre> <pre><code>k get repositories.config.pkg.pkgserver.dev repo-target \n</code></pre> <pre><code>NAME          READY   DEPLOYMENT   TYPE   ADDRESS\nrepo-target   True    true         git    https://github.com/pkgserver-dev/pkgserver-demo-target.git\n</code></pre> <p>Discovery is NOT performed by the <code>pkgserver</code> for deployment repositories. As such packages are not discovered automatically be the <code>pkgserver</code>.</p>"},{"location":"03-userguide/04_package_discovery_introspection/","title":"Package discovery and introspection","text":"<p>You can introspect packages in various ways from listing to checking the content. Here is how you can look at all the package revisions in your system.</p> kubectlpkgctl <pre><code>kubectl get packagerevisions\n</code></pre> <p>You should see an output if you have packages created or discovered in a catalog repository.</p> <pre><code>NAME                                 REPOSITORY     TARGET    REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ncatalog.repo-catalog.nf.example.v1   repo-catalog   catalog   nf      example   v1         v1          published\ncatalog.repo-catalog.nf.example.v2   repo-catalog   catalog   nf      example   v2         v2          published\ncatalog.repo-catalog.nf.example.v3   repo-catalog   catalog   nf      example   v3         v3          published\n</code></pre> <pre><code>pkgctl rpkg get\n</code></pre> <p>You should see an output if you have packages created or discovered in a catalog repository.</p> <pre><code>NAME                                 REPOSITORY     TARGET    REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ncatalog.repo-catalog.nf.example.v1   repo-catalog   catalog   nf      example   v1         v1          published\ncatalog.repo-catalog.nf.example.v2   repo-catalog   catalog   nf      example   v2         v2          published\ncatalog.repo-catalog.nf.example.v3   repo-catalog   catalog   nf      example   v3         v3          published\n</code></pre> <p>The putput show an overview of the various package revisions with its identifiers and lifecycle.</p> <p>if you are interested in a specfic package revision, you can filter using the field-selector or label-selector. Both are standard kubectl primitives we leverage also here. E.g showing all packages of a specific revision. You can filter based on all the respective identifiers of a package revision. These filters can be combined to perform more sophisticated queries. E.g. The below command show all packages with revision identifier equal to v3.</p> kubectlpkgctl <pre><code>kubectl get packagerevision --field-selector=spec.packageID.revision=v3\n</code></pre> <pre><code>NAME                                 REPOSITORY     TARGET    REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ncatalog.repo-catalog.nf.example.v3   repo-catalog   catalog   nf      example   v3         v3          published\n</code></pre> <pre><code>pkgctl rpkg get --revision v3\n</code></pre> <pre><code>NAME                                 REPOSITORY     TARGET    REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ncatalog.repo-catalog.nf.example.v3   repo-catalog   catalog   nf      example   v3         v3          published\n</code></pre> <p>If you are interested to show the content of a package revision, this is possible using the following command. The packageRevisionResources is designed to access the resource of a package.</p> kubectlpkgctl <pre><code>kubectl get packagerevisionresources\n</code></pre> <pre><code>NAME                                 REPOSITORY     REALM     PACKAGE   PACKAGE   REVISION   WORKSPACE   FILES\ncatalog.repo-catalog.nf.example.v1   repo-catalog   catalog   nf        example   v1         v1          1\ncatalog.repo-catalog.nf.example.v2   repo-catalog   catalog   nf        example   v2         v2          1\ncatalog.repo-catalog.nf.example.v3   repo-catalog   catalog   nf        example   v3         v3          1\n</code></pre> <p>This is not supported in pkgctl at this stage</p> <p>Similar to the package revision you can also see how many files are contained in each package revision. If you want to see that content of a specific package revision you can just identify the package revision and provide -o yaml.</p> kubectlpkgctl <pre><code>kubectl describe packagerevisionresourceses.pkg.pkgserver.dev catalog.repo-catalog.nf.example.v3\n</code></pre> <pre><code>Name:         catalog.repo-catalog.nf.example.v3\nNamespace:    default\nLabels:       &lt;none&gt;\nAnnotations:  pkg.pkgserver.dev/DiscoveredPkgRev: true\nAPI Version:  pkg.pkgserver.dev/v1alpha1\nKind:         PackageRevisionResources\nMetadata:\nCreation Timestamp:  2024-05-14T18:39:43Z\nFinalizers:\npackagediscovery.pkg.pkgserver.dev/finalizer\npackagerevision.pkg.pkgserver.dev/finalizer\nResource Version:  223532\nUID:               5abb5230-172d-4d00-b4e0-ebff6c7f85cd\nSpec:\nPackage ID:\nPackage:     example\nRealm:       nf\nRepository:  repo-catalog\nRevision:    v3\nTarget:      catalog\nWorkspace:   v3\nResources:\nartifacts.yaml:  ---\n# blockType: input, resourceID: context\n# defines the input of the Kform package as a configmap KRM resource\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: example\nnamespace: default\nannotations:\nkform.dev/block-type: input\nkform.dev/resource-id: context kform.dev/default: \"true\"\ndata:\nnetworkInstance: vpc-kform\nnetwork: knet1\nnode: a\nep: kep1\n---\n# blockType: provider, resourceID/name: kubernetes\n# defines the kubernetes provider configuration\napiVersion: kubernetes.provider.kform.dev/v1alpha1\nkind: ProviderConfig\nmetadata:\nname: kubernetes\nnamespace: default\nannotations:\nkform.dev/block-type: provider\n#spec: \n#  configPath: \"/Users/henderiw/.kube/config\"\n---\n# blockType: resource, resourceID: deployment, resourceType: kubernetes_manifest\n# deployment KRM resource that will be applied in the system\n# expressions are used to transform the KRM manifest before applying to the system\napiVersion: ipam.be.kuid.dev/v1alpha1\nkind: IPClaim\nmetadata:\nname: vpc-kform.claim1\nnamespace: default\nannotations:\nkform.dev/block-type: resource\nkform.dev/resource-type: kubernetes_manifest kform.dev/resource-id: ipclaim\nspec:\nindex: input.context[0].data.networkInstance\nselector:\nmatchLabels:\ninv.kuid.dev/network: input.context[0].data.network\nlabels:\ninv.kuid.dev/endpoint-name: input.context[0].data.ep\n---\n# blockType: output\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: output\nnamespace: default\ndata:\nprefix: kubernetes_manifest.ipclaim[0].status.address\ndefaultGateway: kubernetes_manifest.ipclaim[0].status.defaultGateway\nStatus:\nEvents:  &lt;none&gt;\n</code></pre> <p>if you dont supply a directory in the command the command will be shown to the screen, wheras if a directory is supplied the files in the package will be stored relative to the directory supplied.</p> <p>Example command to store the files in the filesystem</p> <pre><code>pkgctl rpkg pull catalog.repo-catalog.nf.example.v3  example\n</code></pre> <pre><code>tree example    \nexample\n\u2514\u2500\u2500 artifacts.yaml\n</code></pre> <p>Example command to show the output to the screen</p> <pre><code>pkgctl rpkg pull catalog.repo-catalog.nf.example.v3 \n</code></pre> <pre><code>path: artifacts.yaml\n---\n# blockType: input, resourceID: context\n# defines the input of the Kform package as a configmap KRM resource\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: example\nnamespace: default\nannotations:\nkform.dev/block-type: input\nkform.dev/resource-id: context kform.dev/default: \"true\"\ndata:\nnetworkInstance: vpc-kform\nnetwork: knet1\nnode: a\nep: kep1\n---\n# blockType: provider, resourceID/name: kubernetes\n# defines the kubernetes provider configuration\napiVersion: kubernetes.provider.kform.dev/v1alpha1\nkind: ProviderConfig\nmetadata:\nname: kubernetes\nnamespace: default\nannotations:\nkform.dev/block-type: provider\n#spec: \n#  configPath: \"/Users/henderiw/.kube/config\"\n---\n# blockType: resource, resourceID: deployment, resourceType: kubernetes_manifest\n# deployment KRM resource that will be applied in the system\n# expressions are used to transform the KRM manifest before applying to the system\napiVersion: ipam.be.kuid.dev/v1alpha1\nkind: IPClaim\nmetadata:\nname: vpc-kform.claim1\nnamespace: default\nannotations:\nkform.dev/block-type: resource\nkform.dev/resource-type: kubernetes_manifest kform.dev/resource-id: ipclaim\nspec:\nindex: input.context[0].data.networkInstance\nselector:\nmatchLabels:\ninv.kuid.dev/network: input.context[0].data.network\nlabels:\ninv.kuid.dev/endpoint-name: input.context[0].data.ep\n---\n# blockType: output\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: output\nnamespace: default\ndata:\nprefix: kubernetes_manifest.ipclaim[0].status.address\ndefaultGateway: kubernetes_manifest.ipclaim[0].status.defaultGateway\n</code></pre>"},{"location":"03-userguide/05_package_authoring/","title":"Package authoring","text":"<p>There is various ways to author a package</p>"},{"location":"03-userguide/05_package_authoring/#creating-a-new-package-revision","title":"Creating a new package revision","text":"<p>This creates a new package from scratch</p> kubectlpkgctl <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: pkg.pkgserver.dev/v1alpha1\nkind: PackageRevision\nmetadata:\nname: dummy.repo-target.nf.example.ws1\nnamespace: default\nspec:\npackageID:\ntarget: dummy\nrepository: repo-target\nrealm: nf\npackage: example\nworkspace: ws1\nlifecycle: draft\ntasks:\n- type: init EOF\n</code></pre> <p>When the package revision is successfully created the package should be visible using the following command</p> <pre><code>kubectl get packagerevisions.pkg.pkgserver.dev dummy.repo-target.nf.example.ws1\n</code></pre> <pre><code>NAME                               READY   REPOSITORY    TARGET   REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ndummy.repo-target.nf.example.ws1   True    repo-target   dummy    nf      example              ws1         draft\n</code></pre> <pre><code>pkgctl rpkg create dummy.repo-target.nf.example.ws1\n</code></pre> <p>When the package revision is successfully created the package should be visible in the following command</p> <pre><code>pkgctl rpkg get dummy.repo-target.nf.example.ws1\n</code></pre> <pre><code>NAME                               READY   REPOSITORY    TARGET   REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ndummy.repo-target.nf.example.ws1   True    repo-target   dummy    nf      example              ws1         draft\n</code></pre>"},{"location":"03-userguide/05_package_authoring/#cloning-a-package-revision","title":"Cloning a package revision","text":"<p>To clone a package revision into another, you must provide both the target package revision and the upstream package revision, which serves as the source for the content of the new/target package revision.</p> kubectlpkgctl <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: pkg.pkgserver.dev/v1alpha1\nkind: PackageRevision\nmetadata:\nname: dummy.repo-target.nf.example.ws1\nnamespace: default\nspec:\npackageID:\ntarget: dummy\nrepository: repo-target\nrealm: nf\npackage: example\nworkspace: ws1\nlifecycle: draft\ntasks:\n- type: clone\nupstream:\npackage: example\nrealm: nf\nrepository: repo-catalog\nrevision: v3\nEOF\n</code></pre> <p>When the package revision is successfully created the package should be visible with the following command</p> <pre><code>kubectl get packagerevisions.pkg.pkgserver.dev dummy.repo-target.nf.example.ws1\n</code></pre> <pre><code>NAME                               READY   REPOSITORY    TARGET   REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ndummy.repo-target.nf.example.ws1   True    repo-target   dummy    nf      example              ws1         draft\n</code></pre> <pre><code>pkgctl rpkg clone dummy.repo-target.nf.example.ws1 catalog.repo-catalog.nf.example.v3\n</code></pre> <p>When the package revision is successfully created the package should be visible in the following command</p> <pre><code>pkgctl rpkg get dummy.repo-target.nf.example.ws1\n</code></pre> <pre><code>NAME                               READY   REPOSITORY    TARGET   REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ndummy.repo-target.nf.example.ws1   True    repo-target   dummy    nf      example              ws1         draft\n</code></pre>"},{"location":"03-userguide/05_package_authoring/#updating-a-package-revision","title":"Updating a package revision","text":"<p>When you want to change the content of an exiting package, the following comamnds should help you</p> kubectlpkgctl <p>not supported</p> <p>First ensure you have the content local in a directory. E.g. using the following command, which will create the files of the package revision in the local directory supplied (example in this example)</p> <pre><code>pkgctl rpkg pull dummy.repo-target.nf.example.ws1 example\n</code></pre> <p>After editing the respecitve files, you can upload the new content using the following command</p> <pre><code>pkgctl rpkg push dummy.repo-target.nf.example.ws1 example\n</code></pre> <p>you can show the result of the change using the following command.</p> <pre><code>pkgctl rpkg pull dummy.repo-target.nf.example.ws1\n</code></pre>"},{"location":"03-userguide/05_package_authoring/#deleting-a-package-revision","title":"Deleting a package revision","text":"<p>If you want to delete a package revision that is not in published state, the following methods should allow to delete the package revision. If the package revision is in published state you should update to lifecycle to deletionproposed before executing the below commands</p> kubectlpkgctl <pre><code>kubectl delete packagerevisions dummy.repo-target.nf.example.ws1\n</code></pre> <pre><code>kubectl get packagerevisions dummy.repo-target.nf.example.ws1\nError from server (NotFound): packagerevisions.pkg.pkgserver.dev \"dummy.repo-target.nf.example.ws1\" not found\n</code></pre> <pre><code>pkgctl rpkg delete dummy.repo-target.nf.example\n</code></pre> <pre><code>pkgctl rpkg get dummy.repo-target.nf.example\nthe server could not find the requested resource (get packagerevisions.pkg.pkgserver.dev dummy.repo-target.nf.example)\n</code></pre>"},{"location":"03-userguide/06_package_lifecycle/","title":"Package Lifecycle and approval flow","text":"<p>Authoring of a package revision is executed in the draft lifecycle state. Before a package can be deployed and even cloned a package must be published. The approval flow is the process by which the package revision is advanced from draft state through proposed state and finally to a published stage.</p> <p>In these example a package revision is available in the draft state</p> <pre><code>kubectl get packagerevisions.pkg.pkgserver.dev dummy.repo-target.nf.example.ws1\nNAME                               READY   REPOSITORY    TARGET   REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ndummy.repo-target.nf.example.ws1   True    repo-target   dummy    nf      example              ws1         draft\n</code></pre>"},{"location":"03-userguide/06_package_lifecycle/#propose-a-package-revision-draft-proposed","title":"Propose a package revision (draft -&gt; proposed)","text":"<p>After editing is completed, the package revision will transition to a proposed state, that will trigger an authoratative entity to either reject or approve the package</p> kubectlpkgct <p>kubectl to be updated, check for the pkgct option</p> <pre><code>pkgctl rpkg updatestatus dummy.repo-target.nf.example.ws1 proposed\n</code></pre> <pre><code>pkgctl rpkg get dummy.repo-target.nf.example.ws1\nNAME                               READY   REPOSITORY    TARGET   REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ndummy.repo-target.nf.example.ws1   True    repo-target   dummy    nf      example              ws1         proposed\n</code></pre>"},{"location":"03-userguide/06_package_lifecycle/#reject-a-package-revision-proposed-draft","title":"Reject a package revision (proposed -&gt; draft)","text":"<p>A package can be rejected using the following command</p> kubectlpkgctl <p>kubectl to be updated, check for the pkgct option</p> <pre><code>pkgctl rpkg updatestatus dummy.repo-target.nf.example.ws1 draft \n</code></pre> <pre><code>pkgctl rpkg get dummy.repo-target.nf.example.ws1               \nNAME                               READY   REPOSITORY    TARGET   REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ndummy.repo-target.nf.example.ws1   True    repo-target   dummy    nf      example              ws1         draft\n</code></pre>"},{"location":"03-userguide/06_package_lifecycle/#approve-a-package-revision-proposed-publish","title":"Approve a package revision (proposed -&gt; publish)","text":"<p>A package can be approved using the following command. Also note that a revision is allocated for the package once approved. At this stage the package revision can no longer be edited. When using git at this stage a tag will be allocated reflecting a pointer to this package revision. On top you will also see the content in merged into the main branch from the workspace branch.</p> kubectlpkgctl <p>kubectl to be updated, check for the pkgct option</p> <pre><code>pkgctl rpkg updatestatus dummy.repo-target.nf.example.ws1 published\n</code></pre> <pre><code>NAME                               READY   REPOSITORY    TARGET   REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ndummy.repo-target.nf.example.ws1   True    repo-target   dummy    nf      example   v1         ws1         published\n</code></pre>"},{"location":"03-userguide/06_package_lifecycle/#delete-an-approved-package-revision-proposed-deleteionproposed-deleted","title":"Delete an approved package revision (proposed -&gt; deleteionProposed -&gt; deleted)","text":"<p>A package that was approved can be deleted using the folliwng commands</p> kubectlpkgctl <p>kubectl to be updated, check for the pkgct option</p> <pre><code>pkgctl rpkg updatestatus dummy.repo-target.nf.example.ws1 deletionProposed\n</code></pre> <pre><code>pkgctl rpkg get dummy.repo-target.nf.example.ws1                          \nNAME                               READY   REPOSITORY    TARGET   REALM   PACKAGE   REVISION   WORKSPACE   LIFECYCLE\ndummy.repo-target.nf.example.ws1   True    repo-target   dummy    nf      example   v1         ws1         deletionProposed\n</code></pre> <pre><code>pkgctl rpkg delete dummy.repo-target.nf.example.ws1   \n</code></pre> <pre><code>pkgctl rpkg get dummy.repo-target.nf.example.ws1   \nthe server could not find the requested resource (get packagerevisions.pkg.pkgserver.dev dummy.repo-target.nf.example.ws1) \n</code></pre>"},{"location":"03-userguide/10_api/","title":"Repository","text":""},{"location":"03-userguide/overall/","title":"Repository","text":"<p>registering a repository</p> <p>Package Discovery And Introspection</p> <p>package authoring</p> <p>clone an existing package</p> <p>create a new revision of an existing package</p> <p>editing package revision resources</p> <p>package lifecycle -&gt; draft -&gt; proposed -&gt; published -&gt; deleteionpropsosed -&gt; deleted</p>"},{"location":"04-examples/01_about/","title":"Examples","text":""},{"location":"04-examples/02_package_variant/","title":"Package Variant","text":"<p>Package Variant with no variable input</p> <pre><code>apiVersion: config.pkg.pkgserver.dev/v1alpha1\nkind: PackageVariant\nmetadata:\nname: pv-kform-test\nnamespace: default\nspec:\nupstream:\nrepository: repo-catalog\nrealm: nf\npackage: example\nrevision: v3\ndownstream:\ntarget: dummy\nrepository: repo-target\nrealm: nf\npackage: example\npackageContext:\nreadinessGates:\n- conditionType: pkg.pkgserver.dev/process\nlabels:\na: b\nannotations:\npolicy.pkg.kform.dev/approval: initial\n</code></pre> <p>Package Variant with variable input</p> <pre><code>apiVersion: config.pkg.pkgserver.dev/v1alpha1\nkind: PackageVariant\nmetadata:\nname: pv-kform-test\nnamespace: default\nspec:\nupstream:\nrepository: repo-catalog\nrealm: nf\npackage: example\nrevision: v3\ndownstream:\ntarget: dummy2\nrepository: repo-target\nrealm: nf\npackage: example\npackageContext:\nreadinessGates:\n- conditionType: pkg.pkgserver.dev/process\nlabels:\na: b\nannotations:\npolicy.pkg.kform.dev/approval: initial\ninputs:\n- apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: example\nnamespace: default\nannotations:\nkform.dev/resource-id: context data:\nnetworkInstance: vpc-kform2\nnetwork: knet2\nnode: b\nep: kep2\n</code></pre>"},{"location":"05-dev/01_about/","title":"Development guide","text":""},{"location":"06-rn/rn/","title":"pkgserver release notes","text":"<p>We are stil in the early phases of our development, therefore we do not publish aggregated release notes for each of our releases. </p> <p>Release summaries are available on GitHub:</p> <ul> <li>pkgserver</li> <li>pkgctl</li> </ul>"},{"location":"07-community/01_about/","title":"Community","text":"<p>Join us in this jurney to build a package orchestrator server for KRM packages.</p> <p>pkgserver was started and currently maintained by Nokia with the clear target to make the project community driven.</p> <p>The functionality of pkgserver overlaps with Porch and have the potential to replace Porch in the Nephio architecture.</p>"},{"location":"07-community/01_about/#kubenet","title":"Kubenet","text":"<p>If you are intrested in a biger picture about how do we imagine network manegement in a Kubernetes native way check out Kubenet. </p>"}]}